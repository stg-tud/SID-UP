currently broken:
    - late signal creation from remote
    - signal creation when the system is active
    - exception handling
    - garbage collection of parts of the network

+   3   separate set of actually involved sources and source (ordering source?) predecessor map
++  15  dependency set changes
        -> Signal.rmap
0   2   make an ListMergeEventStream that merges multiple concurrently ocurring events into a single event of a list of events
+   3   make an EventStream equivalent of HoldSignal
        -> possibly replace HoldSignal by this eventStream.hold(initialValue)
        -> use for eventstream lifting functions
+   3   lazy evaluation desired, purpose? is that different if exception handling is available? 
++  >>> signal profiling to optimize through lowering or premature propagation of quickly calculated results instead of waiting to see if recalculation is necessary   
+   ??  implement more funny event things
        -> and-event
        -> "not" event??
+   5   proper solution for source dependencies / late reactive creation
        -> Map[UUID, UUID] to Map[UUID, (UUID, Set[UUID])] of lastEvent and set of early-propagated events per source? 
+   10  implement proper demo application (CRUD??)
+   3   omitting of pointless recalculations, e.g. if the currently unaccessed else part of an if condition changed
        -> requires profiling of previous evaluation, thus requires sequential evaluation.
            -> criteria for good or bad? sounds like it depends on system load?
            -> maybe implement as "if immediate predecessor evaluation happens to be finished, use it's profiling, otherwise just recalculate concurrently"?
0   2   implement exception propagation
0   2   clean up garbage collection prevention of Signal.lastEvent thingy
        -> maybe just use WeakReference?
0   3   allow partial GC of dependency graphs bottom up (discard var's and dependants that aren't referenced anymore and thus won't produce further updates)
0   3   allow partial GC of dependency graphs top down (hold unobserved dependants with weak references so they can be discarded if no outside holds on to them) 
0   2   allow remote var inclusion in transactions
+   10  add communication failure / duplicate tolerance
+   10  bidirectional signals/reactives